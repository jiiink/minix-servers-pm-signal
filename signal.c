/* This file handles signals, which are asynchronous events and are generally
 * a messy and unpleasant business.  Signals can be generated by the KILL
 * system call, or from the keyboard (SIGINT) or from the clock (SIGALRM).
 * In all cases control eventually passes to check_sig() to see which processes
 * can be signaled.  The actual signaling is done by sig_proc().
 *
 * The entry points into this file are:
 *   do_sigaction:	perform the SIGACTION system call
 *   do_sigpending:	perform the SIGPENDING system call
 *   do_sigprocmask:	perform the SIGPROCMASK system call
 *   do_sigreturn:	perform the SIGRETURN system call
 *   do_sigsuspend:	perform the SIGSUSPEND system call
 *   do_kill:		perform the KILL system call
 *   process_ksig:	process a signal an behalf of the kernel
 *   sig_proc:		interrupt or terminate a signaled process
 *   check_sig:		check which processes to signal with sig_proc()
 *   check_pending:	check if a pending signal can now be delivered
 *   restart_sigs: 	restart signal work after finishing a VFS call
 */

#include "pm.h"
#include <sys/stat.h>
#include <sys/ptrace.h>
#include <minix/callnr.h>
#include <minix/endpoint.h>
#include <minix/com.h>
#include <minix/vm.h>
#include <signal.h>
#include <sys/resource.h>
#include <assert.h>
#include "mproc.h"

static int unpause(struct mproc *rmp);
static int sig_send(struct mproc *rmp, int signo);
static void sig_proc_exit(struct mproc *rmp, int signo);

/*===========================================================================*
 *				do_sigaction				     *
 *===========================================================================*/
int validate_signal_number(int sig_nr)
{
    if (sig_nr == SIGKILL) return OK;
    if (sig_nr < 1 || sig_nr >= _NSIG) return EINVAL;
    return -1;
}

int copy_old_action(struct sigaction *svp)
{
    if (m_in.m_lc_pm_sig.oact != 0) {
        return sys_datacopy(PM_PROC_NR, (vir_bytes)svp, who_e,
                           m_in.m_lc_pm_sig.oact, (phys_bytes)sizeof(struct sigaction));
    }
    return OK;
}

int read_new_action(struct sigaction *svec)
{
    return sys_datacopy(who_e, m_in.m_lc_pm_sig.act, PM_PROC_NR, 
                       (vir_bytes)svec, (phys_bytes)sizeof(struct sigaction));
}

void handle_sig_ign(int sig_nr)
{
    sigaddset(&mp->mp_ignore, sig_nr);
    sigdelset(&mp->mp_sigpending, sig_nr);
    sigdelset(&mp->mp_ksigpending, sig_nr);
    sigdelset(&mp->mp_catch, sig_nr);
}

void handle_sig_dfl(int sig_nr)
{
    sigdelset(&mp->mp_ignore, sig_nr);
    sigdelset(&mp->mp_catch, sig_nr);
}

void handle_sig_catch(int sig_nr)
{
    sigdelset(&mp->mp_ignore, sig_nr);
    sigaddset(&mp->mp_catch, sig_nr);
}

void update_signal_handler(int sig_nr, struct sigaction *svec)
{
    if (svec->sa_handler == SIG_IGN) {
        handle_sig_ign(sig_nr);
    } else if (svec->sa_handler == SIG_DFL) {
        handle_sig_dfl(sig_nr);
    } else {
        handle_sig_catch(sig_nr);
    }
}

void update_signal_action(int sig_nr, struct sigaction *svec)
{
    mp->mp_sigact[sig_nr].sa_handler = svec->sa_handler;
    sigdelset(&svec->sa_mask, SIGKILL);
    sigdelset(&svec->sa_mask, SIGSTOP);
    mp->mp_sigact[sig_nr].sa_mask = svec->sa_mask;
    mp->mp_sigact[sig_nr].sa_flags = svec->sa_flags;
    mp->mp_sigreturn = m_in.m_lc_pm_sig.ret;
}

int do_sigaction(void)
{
    int r, sig_nr;
    struct sigaction svec;
    struct sigaction *svp;

    assert(!(mp->mp_flags & (PROC_STOPPED | VFS_CALL | UNPAUSED | EVENT_CALL)));

    sig_nr = m_in.m_lc_pm_sig.nr;
    
    r = validate_signal_number(sig_nr);
    if (r != -1) return r;

    svp = &mp->mp_sigact[sig_nr];
    
    r = copy_old_action(svp);
    if (r != OK) return r;

    if (m_in.m_lc_pm_sig.act == 0)
        return OK;

    r = read_new_action(&svec);
    if (r != OK) return r;

    update_signal_handler(sig_nr, &svec);
    update_signal_action(sig_nr, &svec);
    
    return OK;
}

/*===========================================================================*
 *				do_sigpending                                *
 *===========================================================================*/
int do_sigpending(void)
{
  assert(!(mp->mp_flags & (PROC_STOPPED | VFS_CALL | UNPAUSED | EVENT_CALL)));

  mp->mp_reply.m_pm_lc_sigset.set = mp->mp_sigpending;
  return OK;
}

/*===========================================================================*
 *				do_sigprocmask                               *
 *===========================================================================*/
int do_sigprocmask(void)
{
  sigset_t set;

  assert(!(mp->mp_flags & (PROC_STOPPED | VFS_CALL | UNPAUSED | EVENT_CALL)));

  set = m_in.m_lc_pm_sigset.set;
  mp->mp_reply.m_pm_lc_sigset.set = mp->mp_sigmask;

  switch (m_in.m_lc_pm_sigset.how) {
      case SIG_BLOCK:
	return handle_sig_block(set);

      case SIG_UNBLOCK:
	return handle_sig_unblock(set);

      case SIG_SETMASK:
	return handle_sig_setmask(set);

      case SIG_INQUIRE:
	return OK;

      default:
	return EINVAL;
  }
}

static void remove_unmaskable_signals(sigset_t *set)
{
  sigdelset(set, SIGKILL);
  sigdelset(set, SIGSTOP);
}

static void apply_signal_operation(sigset_t *set, void (*operation)(sigset_t *, int))
{
  int i;
  for (i = 1; i < _NSIG; i++) {
    if (sigismember(set, i))
      operation(&mp->mp_sigmask, i);
  }
}

static int handle_sig_block(sigset_t set)
{
  remove_unmaskable_signals(&set);
  apply_signal_operation(&set, sigaddset);
  return OK;
}

static int handle_sig_unblock(sigset_t set)
{
  apply_signal_operation(&set, sigdelset);
  check_pending(mp);
  return OK;
}

static int handle_sig_setmask(sigset_t set)
{
  remove_unmaskable_signals(&set);
  mp->mp_sigmask = set;
  check_pending(mp);
  return OK;
}

/*===========================================================================*
 *				do_sigsuspend                                *
 *===========================================================================*/
int do_sigsuspend(void)
{
  assert(!(mp->mp_flags & (PROC_STOPPED | VFS_CALL | UNPAUSED | EVENT_CALL)));

  mp->mp_sigmask2 = mp->mp_sigmask;
  mp->mp_sigmask = m_in.m_lc_pm_sigset.set;
  sigdelset(&mp->mp_sigmask, SIGKILL);
  sigdelset(&mp->mp_sigmask, SIGSTOP);
  mp->mp_flags |= SIGSUSPENDED;
  check_pending(mp);
  return SUSPEND;
}

/*===========================================================================*
 *				do_sigreturn				     *
 *===========================================================================*/
int do_sigreturn(void)
{
  int r;

  assert(!(mp->mp_flags & (PROC_STOPPED | VFS_CALL | UNPAUSED | EVENT_CALL)));

  mp->mp_sigmask = m_in.m_lc_pm_sigset.set;
  sigdelset(&mp->mp_sigmask, SIGKILL);
  sigdelset(&mp->mp_sigmask, SIGSTOP);

  r = sys_sigreturn(who_e, (struct sigmsg *)m_in.m_lc_pm_sigset.ctx);
  check_pending(mp);
  return(r);
}

/*===========================================================================*
 *				do_kill					     *
 *===========================================================================*/
int do_kill(void)
{
  return check_sig(m_in.m_lc_pm_sig.pid, m_in.m_lc_pm_sig.nr, FALSE);
}

/*===========================================================================*
 *			      do_srv_kill				     *
 *===========================================================================*/
int do_srv_kill(void)
{
  if (mp->mp_endpoint != RS_PROC_NR)
    return EPERM;

  return check_sig(m_in.m_rs_pm_srv_kill.pid, m_in.m_rs_pm_srv_kill.nr, TRUE);
}

/*===========================================================================*
 *				stop_proc				     *
 *===========================================================================*/
static int handle_stop_success(struct mproc *rmp)
{
    rmp->mp_flags |= PROC_STOPPED;
    return TRUE;
}

static int handle_stop_busy(struct mproc *rmp, int may_delay)
{
    if (!may_delay)
        panic("stop_proc: unexpected delay call");
    
    rmp->mp_flags |= DELAY_CALL;
    return FALSE;
}

static int stop_proc(struct mproc *rmp, int may_delay)
{
    int r;
    
    assert(!(rmp->mp_flags & (PROC_STOPPED | DELAY_CALL | UNPAUSED)));
    
    r = sys_delay_stop(rmp->mp_endpoint);
    
    if (r == OK)
        return handle_stop_success(rmp);
    
    if (r == EBUSY)
        return handle_stop_busy(rmp, may_delay);
    
    panic("sys_delay_stop failed: %d", r);
}

/*===========================================================================*
 *				try_resume_proc				     *
 *===========================================================================*/
static int should_skip_resume(struct mproc *rmp)
{
    return (rmp->mp_flags & (VFS_CALL | EVENT_CALL | EXITING)) != 0;
}

static void clear_resume_flags(struct mproc *rmp)
{
    rmp->mp_flags &= ~(PROC_STOPPED | UNPAUSED);
}

static void perform_sys_resume(struct mproc *rmp)
{
    int r;
    
    if ((r = sys_resume(rmp->mp_endpoint)) != OK)
        panic("sys_resume failed: %d", r);
}

static void try_resume_proc(struct mproc *rmp)
{
    assert(rmp->mp_flags & PROC_STOPPED);
    
    if (should_skip_resume(rmp))
        return;
    
    perform_sys_resume(rmp);
    clear_resume_flags(rmp);
}

/*===========================================================================*
 *				process_ksig				     *
 *===========================================================================*/
#define PROCESS_ACTIVE (IN_USE | EXITING)
#define BROADCAST_TO_GROUP 0

static int validate_process(endpoint_t proc_nr_e, int *proc_nr, struct mproc **rmp)
{
    if (pm_isokendpt(proc_nr_e, proc_nr) != OK) {
        printf("PM: process_ksig: %d?? not ok\n", proc_nr_e);
        return EDEADEPT;
    }
    
    *rmp = &mproc[*proc_nr];
    if ((*rmp)->mp_flags & PROCESS_ACTIVE != IN_USE) {
        return EDEADEPT;
    }
    
    return OK;
}

static pid_t get_signal_target(int signo, pid_t proc_id, int proc_nr)
{
    switch (signo) {
        case SIGINT:
        case SIGQUIT:
        case SIGWINCH:
        case SIGINFO:
            return BROADCAST_TO_GROUP;
        case SIGVTALRM:
        case SIGPROF:
            check_vtimer(proc_nr, signo);
            return proc_id;
        default:
            return proc_id;
    }
}

static void setup_pm_context(struct mproc *rmp)
{
    mp = &mproc[0];
    mp->mp_procgrp = rmp->mp_procgrp;
}

static void restore_pm_context(void)
{
    mp->mp_procgrp = 0;
}

static int handle_sigsndelay(struct mproc *rmp)
{
    rmp->mp_flags &= ~DELAY_CALL;
    assert(!(rmp->mp_flags & PROC_STOPPED));
    
    if (rmp->mp_flags & (VFS_CALL | EVENT_CALL)) {
        stop_proc(rmp, FALSE);
        return OK;
    }
    
    check_pending(rmp);
    assert(!(rmp->mp_flags & DELAY_CALL));
    return OK;
}

static int check_process_alive(int proc_nr)
{
    if ((mproc[proc_nr].mp_flags & PROCESS_ACTIVE) == IN_USE) {
        return OK;
    }
    return EDEADEPT;
}

int process_ksig(endpoint_t proc_nr_e, int signo)
{
    struct mproc *rmp;
    int proc_nr;
    pid_t proc_id, id;
    
    int result = validate_process(proc_nr_e, &proc_nr, &rmp);
    if (result != OK) {
        return result;
    }
    
    proc_id = rmp->mp_pid;
    setup_pm_context(rmp);
    
    id = get_signal_target(signo, proc_id, proc_nr);
    check_sig(id, signo, TRUE);
    
    restore_pm_context();
    
    if (signo == SIGSNDELAY && (rmp->mp_flags & DELAY_CALL)) {
        return handle_sigsndelay(rmp);
    }
    
    return check_process_alive(proc_nr);
}

/*===========================================================================*
 *				sig_proc				     *
 *===========================================================================*/
#define SIGNAL_FROM_TRACER TRUE
#define SIGNAL_NOT_FROM_TRACER FALSE
#define SIGNAL_FROM_KERNEL 1
#define SIGNAL_NOT_FROM_KERNEL 0

static int should_pass_to_debugger(struct mproc *rmp, int signo, int trace)
{
    return trace == SIGNAL_FROM_TRACER && 
           rmp->mp_tracer != NO_TRACER && 
           signo != SIGKILL;
}

static void handle_debugger_signal(struct mproc *rmp, int signo)
{
    sigaddset(&rmp->mp_sigtrace, signo);
    if (!(rmp->mp_flags & TRACE_STOPPED))
        trace_stop(rmp, signo);
}

static int is_process_in_call(struct mproc *rmp)
{
    return rmp->mp_flags & (VFS_CALL | EVENT_CALL);
}

static void queue_signal(struct mproc *rmp, int signo, int ksig)
{
    sigaddset(&rmp->mp_sigpending, signo);
    if (ksig)
        sigaddset(&rmp->mp_ksigpending, signo);
}

static void handle_signal_during_call(struct mproc *rmp, int signo, int ksig)
{
    queue_signal(rmp, signo, ksig);
    
    if (!(rmp->mp_flags & (PROC_STOPPED | DELAY_CALL))) {
        stop_proc(rmp, FALSE);
    }
}

static int is_pm_process(struct mproc *rmp)
{
    return rmp->mp_endpoint == PM_PROC_NR;
}

static void forward_to_kernel(struct mproc *rmp, int signo)
{
    sys_kill(rmp->mp_endpoint, signo);
}

static void handle_stacktrace_signal(int signo, struct mproc *rmp)
{
    if (SIGS_IS_STACKTRACE(signo)) {
        sys_diagctl_stacktrace(rmp->mp_endpoint);
    }
}

static void send_signal_message(struct mproc *rmp, int signo)
{
    message m;
    m.m_type = SIGS_SIGNAL_RECEIVED;
    m.m_pm_lsys_sigs_signal.num = signo;
    asynsend3(rmp->mp_endpoint, &m, AMF_NOREPLY);
}

static void handle_system_signal(struct mproc *rmp, int signo, int ksig)
{
    if (is_pm_process(rmp))
        return;
    
    if (!ksig) {
        forward_to_kernel(rmp, signo);
        return;
    }
    
    handle_stacktrace_signal(signo, rmp);
    
    if (!SIGS_IS_TERMINATION(signo)) {
        send_signal_message(rmp, signo);
    } else {
        sig_proc_exit(rmp, signo);
    }
}

static int is_bad_ignore(struct mproc *rmp, int signo, int ksig)
{
    return ksig && sigismember(&noign_sset, signo) && 
           (sigismember(&rmp->mp_ignore, signo) || 
            sigismember(&rmp->mp_sigmask, signo));
}

static int should_ignore_signal(struct mproc *rmp, int signo, int badignore)
{
    return !badignore && sigismember(&rmp->mp_ignore, signo);
}

static int should_block_signal(struct mproc *rmp, int signo, int badignore)
{
    return !badignore && sigismember(&rmp->mp_sigmask, signo);
}

static int is_stopped_for_debugger(struct mproc *rmp, int signo)
{
    return (rmp->mp_flags & TRACE_STOPPED) && signo != SIGKILL;
}

static int should_catch_signal(struct mproc *rmp, int signo, int badignore)
{
    return !badignore && sigismember(&rmp->mp_catch, signo);
}

static int should_ignore_by_default(int signo, int badignore)
{
    return !badignore && sigismember(&ign_sset, signo);
}

static void handle_caught_signal(struct mproc *rmp, int signo, int ksig)
{
    if (!unpause(rmp)) {
        queue_signal(rmp, signo, ksig);
        return;
    }
    
    if (sig_send(rmp, signo))
        return;
    
    printf("PM: %d can't catch signal %d - killing\n", rmp->mp_pid, signo);
    sig_proc_exit(rmp, signo);
}

void sig_proc(register struct mproc *rmp, int signo, int trace, int ksig)
{
    int slot, badignore;
    
    slot = (int)(rmp - mproc);
    if ((rmp->mp_flags & (IN_USE | EXITING)) != IN_USE) {
        panic("PM: signal %d sent to exiting process %d\n", signo, slot);
    }
    
    if (should_pass_to_debugger(rmp, signo, trace)) {
        handle_debugger_signal(rmp, signo);
        return;
    }
    
    if (is_process_in_call(rmp)) {
        handle_signal_during_call(rmp, signo, ksig);
        return;
    }
    
    if (rmp->mp_flags & PRIV_PROC) {
        handle_system_signal(rmp, signo, ksig);
        return;
    }
    
    badignore = is_bad_ignore(rmp, signo, ksig);
    
    if (should_ignore_signal(rmp, signo, badignore))
        return;
    
    if (should_block_signal(rmp, signo, badignore)) {
        queue_signal(rmp, signo, ksig);
        return;
    }
    
    if (is_stopped_for_debugger(rmp, signo)) {
        queue_signal(rmp, signo, ksig);
        return;
    }
    
    if (should_catch_signal(rmp, signo, badignore)) {
        handle_caught_signal(rmp, signo, ksig);
        return;
    }
    
    if (should_ignore_by_default(signo, badignore))
        return;
    
    sig_proc_exit(rmp, signo);
}

/*===========================================================================*
 *				sig_proc_exit				     *
 *===========================================================================*/
static void sig_proc_exit(struct mproc *rmp, int signo)
{
    rmp->mp_sigstatus = (char) signo;
    int should_dump_core = should_create_core_dump(rmp, signo);
    exit_proc(rmp, 0, should_dump_core);
}

static int should_create_core_dump(struct mproc *rmp, int signo)
{
    if (!sigismember(&core_sset, signo)) {
        return FALSE;
    }
    
    if (!(rmp->mp_flags & PRIV_PROC)) {
        log_coredump_signal(rmp, signo);
    }
    
    return TRUE;
}

static void log_coredump_signal(struct mproc *rmp, int signo)
{
    printf("PM: coredump signal %d for %d / %s\n", 
           signo, rmp->mp_pid, rmp->mp_name);
    sys_diagctl_stacktrace(rmp->mp_endpoint);
}

/*===========================================================================*
 *				check_sig				     *
 *===========================================================================*/
int check_sig(proc_id, signo, ksig)
pid_t proc_id;			/* pid of proc to sig, or 0 or -1, or -pgrp */
int signo;			/* signal to send to process (0 to _NSIG-1) */
int ksig;			/* non-zero means signal comes from kernel  */
{
/* Check to see if it is possible to send a signal.  The signal may have to be
 * sent to a group of processes.  This routine is invoked by the KILL system
 * call, and also when the kernel catches a DEL or other signal.
 */

  register struct mproc *rmp;
  int count;			/* count # of signals sent */
  int error_code;

  if (signo < 0 || signo >= _NSIG) return(EINVAL);

  /* Return EINVAL for attempts to send SIGKILL to INIT alone. */
  if (proc_id == INIT_PID && signo == SIGKILL) return(EINVAL);

  /* Signal RS first when broadcasting SIGTERM. */
  if (proc_id == -1 && signo == SIGTERM)
      sys_kill(RS_PROC_NR, signo);

  /* Search the proc table for processes to signal. Start from the end of the
   * table to analyze core system processes at the end when broadcasting.
   * (See forkexit.c about pid magic.)
   */
  count = 0;
  error_code = ESRCH;
  for (rmp = &mproc[NR_PROCS-1]; rmp >= &mproc[0]; rmp--) {
	if (!(rmp->mp_flags & IN_USE)) continue;

	/* Check for selection. */
	if (proc_id > 0 && proc_id != rmp->mp_pid) continue;
	if (proc_id == 0 && mp->mp_procgrp != rmp->mp_procgrp) continue;
	if (proc_id == -1 && rmp->mp_pid <= INIT_PID) continue;
	if (proc_id < -1 && rmp->mp_procgrp != -proc_id) continue;

	/* Do not kill servers and drivers when broadcasting SIGKILL. */
	if (proc_id == -1 && signo == SIGKILL &&
		(rmp->mp_flags & PRIV_PROC)) continue;

	/* Skip VM entirely as it might lead to a deadlock with its signal
	 * manager if the manager page faults at the same time.
	 */
	if (rmp->mp_endpoint == VM_PROC_NR) continue;

	/* Disallow lethal signals sent by user processes to sys processes. */
	if (!ksig && SIGS_IS_LETHAL(signo) && (rmp->mp_flags & PRIV_PROC)) {
	    error_code = EPERM;
	    continue;
	}

	/* Check for permission. */
	if (mp->mp_effuid != SUPER_USER
	    && mp->mp_realuid != rmp->mp_realuid
	    && mp->mp_effuid != rmp->mp_realuid
	    && mp->mp_realuid != rmp->mp_effuid
	    && mp->mp_effuid != rmp->mp_effuid) {
		error_code = EPERM;
		continue;
	}

	count++;
	if (signo == 0 || (rmp->mp_flags & EXITING)) continue;

	/* 'sig_proc' will handle the disposition of the signal.  The
	 * signal may be caught, blocked, ignored, or cause process
	 * termination, possibly with core dump.
	 */
	sig_proc(rmp, signo, TRUE /*trace*/, ksig);

	if (proc_id > 0) break;	/* only one process being signaled */
  }

  /* If the calling process has killed itself, don't reply. */
  if ((mp->mp_flags & (IN_USE | EXITING)) != IN_USE) return(SUSPEND);
  return(count > 0 ? OK : error_code);
}

/*===========================================================================*
 *				check_pending				     *
 *===========================================================================*/
void
check_pending(register struct mproc *rmp)
{
  int i;
  
  for (i = 1; i < _NSIG; i++) {
    if (should_deliver_signal(rmp, i)) {
      deliver_pending_signal(rmp, i);
      
      if (must_wait_for_reply(rmp)) {
        assert(rmp->mp_flags & PROC_STOPPED);
        break;
      }
    }
  }
}

static int
should_deliver_signal(struct mproc *rmp, int signal_num)
{
  return sigismember(&rmp->mp_sigpending, signal_num) &&
         !sigismember(&rmp->mp_sigmask, signal_num);
}

static void
deliver_pending_signal(struct mproc *rmp, int signal_num)
{
  int ksig = sigismember(&rmp->mp_ksigpending, signal_num);
  sigdelset(&rmp->mp_sigpending, signal_num);
  sigdelset(&rmp->mp_ksigpending, signal_num);
  sig_proc(rmp, signal_num, FALSE, ksig);
}

static int
must_wait_for_reply(struct mproc *rmp)
{
  return rmp->mp_flags & (VFS_CALL | EVENT_CALL);
}

/*===========================================================================*
 *				restart_sigs				     *
 *===========================================================================*/
void
restart_sigs(struct mproc *rmp)
{
  if (rmp->mp_flags & (VFS_CALL | EVENT_CALL | EXITING)) return;

  if (rmp->mp_flags & TRACE_EXIT) {
    exit_proc(rmp, rmp->mp_exitstatus, FALSE);
    return;
  }
  
  if (!(rmp->mp_flags & PROC_STOPPED)) return;
  
  assert(!(rmp->mp_flags & DELAY_CALL));
  check_pending(rmp);
  try_resume_proc(rmp);
}

/*===========================================================================*
 *				unpause					     *
 *===========================================================================*/
static int
unpause(
	struct mproc *rmp
)
{
	message m;

	assert(!(rmp->mp_flags & (VFS_CALL | EVENT_CALL)));

	if (rmp->mp_flags & UNPAUSED) {
		assert((rmp->mp_flags & (DELAY_CALL | PROC_STOPPED)) == PROC_STOPPED);
		return TRUE;
	}

	if (rmp->mp_flags & DELAY_CALL)
		return FALSE;

	if (rmp->mp_flags & (WAITING | SIGSUSPENDED)) {
		stop_proc(rmp, FALSE);
		return TRUE;
	}

	if (!(rmp->mp_flags & PROC_STOPPED) && !stop_proc(rmp, TRUE))
		return FALSE;

	memset(&m, 0, sizeof(m));
	m.m_type = VFS_PM_UNPAUSE;
	m.VFS_PM_ENDPT = rmp->mp_endpoint;

	tell_vfs(rmp, &m);

	return FALSE;
}

/*===========================================================================*
 *				sig_send				     *
 *===========================================================================*/
static int
sig_send(
	struct mproc *rmp,
	int signo
)
{
	struct sigmsg sigmsg;
	int slot;

	assert(rmp->mp_flags & PROC_STOPPED);

	slot = (int) (rmp - mproc);

	prepare_sigmsg(&sigmsg, rmp, signo);
	update_signal_masks(rmp, signo);
	handle_signal_flags(rmp, signo);
	clear_pending_signals(rmp, signo);

	if (!deliver_signal(rmp, &sigmsg)) {
		return FALSE;
	}

	handle_process_state(rmp, slot);

	return TRUE;
}

static void prepare_sigmsg(struct sigmsg *sigmsg, struct mproc *rmp, int signo)
{
	if (rmp->mp_flags & SIGSUSPENDED)
		sigmsg->sm_mask = rmp->mp_sigmask2;
	else
		sigmsg->sm_mask = rmp->mp_sigmask;
	
	sigmsg->sm_signo = signo;
	sigmsg->sm_sighandler = (vir_bytes) rmp->mp_sigact[signo].sa_handler;
	sigmsg->sm_sigreturn = rmp->mp_sigreturn;
}

static void update_signal_masks(struct mproc *rmp, int signo)
{
	int i;
	
	for (i = 1; i < _NSIG; i++) {
		if (sigismember(&rmp->mp_sigact[signo].sa_mask, i))
			sigaddset(&rmp->mp_sigmask, i);
	}
}

static void handle_signal_flags(struct mproc *rmp, int signo)
{
	int sigflags = rmp->mp_sigact[signo].sa_flags;
	
	if (sigflags & SA_NODEFER)
		sigdelset(&rmp->mp_sigmask, signo);
	else
		sigaddset(&rmp->mp_sigmask, signo);

	if (sigflags & SA_RESETHAND) {
		sigdelset(&rmp->mp_catch, signo);
		rmp->mp_sigact[signo].sa_handler = SIG_DFL;
	}
}

static void clear_pending_signals(struct mproc *rmp, int signo)
{
	sigdelset(&rmp->mp_sigpending, signo);
	sigdelset(&rmp->mp_ksigpending, signo);
}

static int deliver_signal(struct mproc *rmp, struct sigmsg *sigmsg)
{
	int r = sys_sigsend(rmp->mp_endpoint, sigmsg);
	
	if (r == EFAULT || r == ENOMEM) {
		return FALSE;
	}
	
	if (r != OK) {
		panic("sys_sigsend failed: %d", r);
	}
	
	return TRUE;
}

static void handle_process_state(struct mproc *rmp, int slot)
{
	if (rmp->mp_flags & (WAITING | SIGSUSPENDED)) {
		resume_suspended_process(rmp, slot);
	} else {
		assert(rmp->mp_flags & UNPAUSED);
	}
}

static void resume_suspended_process(struct mproc *rmp, int slot)
{
	rmp->mp_flags &= ~(WAITING | SIGSUSPENDED);
	reply(slot, EINTR);
	assert(!(rmp->mp_flags & UNPAUSED));
	try_resume_proc(rmp);
	assert(!(rmp->mp_flags & PROC_STOPPED));
}
