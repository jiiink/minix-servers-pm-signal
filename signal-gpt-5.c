/* This file handles signals, which are asynchronous events and are generally
 * a messy and unpleasant business.  Signals can be generated by the KILL
 * system call, or from the keyboard (SIGINT) or from the clock (SIGALRM).
 * In all cases control eventually passes to check_sig() to see which processes
 * can be signaled.  The actual signaling is done by sig_proc().
 *
 * The entry points into this file are:
 *   do_sigaction:	perform the SIGACTION system call
 *   do_sigpending:	perform the SIGPENDING system call
 *   do_sigprocmask:	perform the SIGPROCMASK system call
 *   do_sigreturn:	perform the SIGRETURN system call
 *   do_sigsuspend:	perform the SIGSUSPEND system call
 *   do_kill:		perform the KILL system call
 *   process_ksig:	process a signal an behalf of the kernel
 *   sig_proc:		interrupt or terminate a signaled process
 *   check_sig:		check which processes to signal with sig_proc()
 *   check_pending:	check if a pending signal can now be delivered
 *   restart_sigs: 	restart signal work after finishing a VFS call
 */

#include "pm.h"
#include <sys/stat.h>
#include <sys/ptrace.h>
#include <minix/callnr.h>
#include <minix/endpoint.h>
#include <minix/com.h>
#include <minix/vm.h>
#include <signal.h>
#include <sys/resource.h>
#include <assert.h>
#include "mproc.h"

static int unpause(struct mproc *rmp);
static int sig_send(struct mproc *rmp, int signo);
static void sig_proc_exit(struct mproc *rmp, int signo);

/*===========================================================================*
 *				do_sigaction				     *
 *===========================================================================*/
int do_sigaction(void)
{
  int r;
  int sig_nr;
  struct sigaction svec;
  struct sigaction *svp;
  const phys_bytes act_sz = (phys_bytes)sizeof(struct sigaction);

  assert(!(mp->mp_flags & (PROC_STOPPED | VFS_CALL | UNPAUSED | EVENT_CALL)));

  sig_nr = m_in.m_lc_pm_sig.nr;
  if (sig_nr == SIGKILL) return OK;
  if (sig_nr < 1 || sig_nr >= _NSIG) return EINVAL;

  svp = &mp->mp_sigact[sig_nr];

  if (m_in.m_lc_pm_sig.oact != 0) {
    r = sys_datacopy(PM_PROC_NR, (vir_bytes)svp, who_e,
        m_in.m_lc_pm_sig.oact, act_sz);
    if (r != OK) return r;
  }

  if (m_in.m_lc_pm_sig.act == 0) return OK;

  r = sys_datacopy(who_e, m_in.m_lc_pm_sig.act, PM_PROC_NR, (vir_bytes)&svec,
      act_sz);
  if (r != OK) return r;

  if (svec.sa_handler == SIG_IGN) {
    sigaddset(&mp->mp_ignore, sig_nr);
    sigdelset(&mp->mp_sigpending, sig_nr);
    sigdelset(&mp->mp_ksigpending, sig_nr);
    sigdelset(&mp->mp_catch, sig_nr);
  } else if (svec.sa_handler == SIG_DFL) {
    sigdelset(&mp->mp_ignore, sig_nr);
    sigdelset(&mp->mp_catch, sig_nr);
  } else {
    sigdelset(&mp->mp_ignore, sig_nr);
    sigaddset(&mp->mp_catch, sig_nr);
  }

  svp->sa_handler = svec.sa_handler;
  sigdelset(&svec.sa_mask, SIGKILL);
  sigdelset(&svec.sa_mask, SIGSTOP);
  svp->sa_mask = svec.sa_mask;
  svp->sa_flags = svec.sa_flags;
  mp->mp_sigreturn = m_in.m_lc_pm_sig.ret;

  return OK;
}

/*===========================================================================*
 *				do_sigpending                                *
 *===========================================================================*/
int do_sigpending(void)
{
    const int disallowed_mask = PROC_STOPPED | VFS_CALL | UNPAUSED | EVENT_CALL;

    assert(mp != NULL);
    assert((mp->mp_flags & disallowed_mask) == 0);

    mp->mp_reply.m_pm_lc_sigset.set = mp->mp_sigpending;
    return OK;
}

/*===========================================================================*
 *				do_sigprocmask                               *
 *===========================================================================*/
static void sanitize_sigmask(sigset_t *set)
{
    sigdelset(set, SIGKILL);
    sigdelset(set, SIGSTOP);
}

static void apply_set_to_mask(sigset_t *mask, const sigset_t *set, int add)
{
    for (int i = 1; i < _NSIG; i++) {
        if (sigismember(set, i)) {
            if (add) {
                sigaddset(mask, i);
            } else {
                sigdelset(mask, i);
            }
        }
    }
}

int do_sigprocmask(void)
{
    sigset_t set;

    assert(!(mp->mp_flags & (PROC_STOPPED | VFS_CALL | UNPAUSED | EVENT_CALL)));

    set = m_in.m_lc_pm_sigset.set;
    mp->mp_reply.m_pm_lc_sigset.set = mp->mp_sigmask;

    switch (m_in.m_lc_pm_sigset.how) {
        case SIG_BLOCK:
            sanitize_sigmask(&set);
            apply_set_to_mask(&mp->mp_sigmask, &set, 1);
            return OK;

        case SIG_UNBLOCK:
            apply_set_to_mask(&mp->mp_sigmask, &set, 0);
            check_pending(mp);
            return OK;

        case SIG_SETMASK:
            sanitize_sigmask(&set);
            mp->mp_sigmask = set;
            check_pending(mp);
            return OK;

        case SIG_INQUIRE:
            return OK;

        default:
            return EINVAL;
    }
}

/*===========================================================================*
 *				do_sigsuspend                                *
 *===========================================================================*/
int do_sigsuspend(void)
{
    sigset_t new_mask;

    assert(!(mp->mp_flags & (PROC_STOPPED | VFS_CALL | UNPAUSED | EVENT_CALL)));

    mp->mp_sigmask2 = mp->mp_sigmask;

    new_mask = m_in.m_lc_pm_sigset.set;
    (void) sigdelset(&new_mask, SIGKILL);
    (void) sigdelset(&new_mask, SIGSTOP);

    mp->mp_sigmask = new_mask;
    mp->mp_flags |= SIGSUSPENDED;

    check_pending(mp);
    return SUSPEND;
}

/*===========================================================================*
 *				do_sigreturn				     *
 *===========================================================================*/
int do_sigreturn(void)
{
  int r;
  sigset_t new_mask;
  struct sigmsg *ctx;

  assert(!(mp->mp_flags & (PROC_STOPPED | VFS_CALL | UNPAUSED | EVENT_CALL)));

  new_mask = m_in.m_lc_pm_sigset.set;
  sigdelset(&new_mask, SIGKILL);
  sigdelset(&new_mask, SIGSTOP);
  mp->mp_sigmask = new_mask;

  ctx = (struct sigmsg *) m_in.m_lc_pm_sigset.ctx;
  r = sys_sigreturn(who_e, ctx);
  check_pending(mp);
  return r;
}

/*===========================================================================*
 *				do_kill					     *
 *===========================================================================*/
int do_kill(void)
{
  return check_sig(m_in.m_lc_pm_sig.pid, m_in.m_lc_pm_sig.nr, 0);
}

/*===========================================================================*
 *			      do_srv_kill				     *
 *===========================================================================*/
int do_srv_kill(void)
{
    if (mp->mp_endpoint != RS_PROC_NR) {
        return EPERM;
    }
    return check_sig(m_in.m_rs_pm_srv_kill.pid, m_in.m_rs_pm_srv_kill.nr, TRUE);
}

/*===========================================================================*
 *				stop_proc				     *
 *===========================================================================*/
static int stop_proc(struct mproc *rmp, int may_delay)
{
  int status;

  assert(!(rmp->mp_flags & (PROC_STOPPED | DELAY_CALL | UNPAUSED)));

  status = sys_delay_stop(rmp->mp_endpoint);

  if (status == OK) {
    rmp->mp_flags |= PROC_STOPPED;
    return TRUE;
  }

  if (status == EBUSY) {
    if (!may_delay) {
      panic("stop_proc: unexpected delay call");
      return FALSE;
    }
    rmp->mp_flags |= DELAY_CALL;
    return FALSE;
  }

  panic("sys_delay_stop failed: %d", status);
  return FALSE;
}

/*===========================================================================*
 *				try_resume_proc				     *
 *===========================================================================*/
static void try_resume_proc(struct mproc *rmp)
{
  int r;
  const int block_mask = VFS_CALL | EVENT_CALL | EXITING;
  const int clear_mask = PROC_STOPPED | UNPAUSED;

  if (rmp == NULL)
    panic("try_resume_proc: null rmp");

  if ((rmp->mp_flags & PROC_STOPPED) == 0)
    panic("try_resume_proc: process not stopped");

  if ((rmp->mp_flags & block_mask) != 0)
    return;

  r = sys_resume(rmp->mp_endpoint);
  if (r != OK)
    panic("sys_resume failed: %d", r);

  rmp->mp_flags &= ~clear_mask;
}

/*===========================================================================*
 *				process_ksig				     *
 *===========================================================================*/
int process_ksig(endpoint_t proc_nr_e, int signo)
{
  struct mproc *rmp;
  int proc_nr;
  pid_t proc_id;
  pid_t id;

  if (pm_isokendpt(proc_nr_e, &proc_nr) != OK) {
    printf("PM: process_ksig: %d?? not ok\n", proc_nr_e);
    return EDEADEPT;
  }

  rmp = &mproc[proc_nr];
  if ((rmp->mp_flags & (IN_USE | EXITING)) != IN_USE) {
    return EDEADEPT;
  }

  proc_id = rmp->mp_pid;
  mp = &mproc[0];
  mp->mp_procgrp = rmp->mp_procgrp;

  id = proc_id;

  switch (signo) {
    case SIGINT:
    case SIGQUIT:
    case SIGWINCH:
    case SIGINFO:
      id = 0;
      break;
    case SIGVTALRM:
    case SIGPROF:
      check_vtimer(proc_nr, signo);
      break;
    default:
      break;
  }

  check_sig(id, signo, TRUE);
  mp->mp_procgrp = 0;

  if (signo == SIGSNDELAY && (rmp->mp_flags & DELAY_CALL)) {
    rmp->mp_flags &= ~DELAY_CALL;

    assert(!(rmp->mp_flags & PROC_STOPPED));

    if (rmp->mp_flags & (VFS_CALL | EVENT_CALL)) {
      stop_proc(rmp, FALSE);
      return OK;
    }

    check_pending(rmp);

    assert(!(rmp->mp_flags & DELAY_CALL));
  }

  return ((rmp->mp_flags & (IN_USE | EXITING)) == IN_USE) ? OK : EDEADEPT;
}

/*===========================================================================*
 *				sig_proc				     *
 *===========================================================================*/
static inline void add_pending_signal(struct mproc *rmp, int signo, int ksig)
{
	sigaddset(&rmp->mp_sigpending, signo);
	if (ksig) sigaddset(&rmp->mp_ksigpending, signo);
}

static int handle_sys_proc_signal(struct mproc *rmp, int signo, int ksig)
{
	if (!(rmp->mp_flags & PRIV_PROC)) return 0;

	if (rmp->mp_endpoint == PM_PROC_NR) return 1;

	if (!ksig) {
		sys_kill(rmp->mp_endpoint, signo);
		return 1;
	}

	if (SIGS_IS_STACKTRACE(signo)) sys_diagctl_stacktrace(rmp->mp_endpoint);

	if (!SIGS_IS_TERMINATION(signo)) {
		message m;
		memset(&m, 0, sizeof(m));
		m.m_type = SIGS_SIGNAL_RECEIVED;
		m.m_pm_lsys_sigs_signal.num = signo;
		asynsend3(rmp->mp_endpoint, &m, AMF_NOREPLY);
	} else {
		sig_proc_exit(rmp, signo);
	}
	return 1;
}

void sig_proc(register struct mproc *rmp, int signo, int trace, int ksig)
{
	int slot, badignore;

	slot = (int) (rmp - mproc);
	if ((rmp->mp_flags & (IN_USE | EXITING)) != IN_USE) {
		panic("PM: signal %d sent to exiting process %d\n", signo, slot);
	}

	if (trace == TRUE && rmp->mp_tracer != NO_TRACER && signo != SIGKILL) {
		sigaddset(&rmp->mp_sigtrace, signo);
		if (!(rmp->mp_flags & TRACE_STOPPED)) trace_stop(rmp, signo);
		return;
	}

	if (rmp->mp_flags & (VFS_CALL | EVENT_CALL)) {
		add_pending_signal(rmp, signo, ksig);
		if (!(rmp->mp_flags & (PROC_STOPPED | DELAY_CALL))) {
			stop_proc(rmp, FALSE);
		}
		return;
	}

	if (handle_sys_proc_signal(rmp, signo, ksig)) return;

	badignore = ksig && sigismember(&noign_sset, signo) &&
		(sigismember(&rmp->mp_ignore, signo) || sigismember(&rmp->mp_sigmask, signo));

	if (!badignore && sigismember(&rmp->mp_ignore, signo)) return;

	if (!badignore && sigismember(&rmp->mp_sigmask, signo)) {
		add_pending_signal(rmp, signo, ksig);
		return;
	}

	if ((rmp->mp_flags & TRACE_STOPPED) && signo != SIGKILL) {
		add_pending_signal(rmp, signo, ksig);
		return;
	}

	if (!badignore && sigismember(&rmp->mp_catch, signo)) {
		if (!unpause(rmp)) {
			add_pending_signal(rmp, signo, ksig);
			return;
		}
		if (sig_send(rmp, signo)) return;
		printf("PM: %d can't catch signal %d - killing\n", rmp->mp_pid, signo);
	} else if (!badignore && sigismember(&ign_sset, signo)) {
		return;
	}

	sig_proc_exit(rmp, signo);
}

/*===========================================================================*
 *				sig_proc_exit				     *
 *===========================================================================*/
static void sig_proc_exit(struct mproc *rmp, int signo)
{
    if (rmp == NULL) {
        return;
    }

    rmp->mp_sigstatus = (char)signo;

    const int dump_core = sigismember(&core_sset, signo);

    if (dump_core && !(rmp->mp_flags & PRIV_PROC)) {
        printf("PM: coredump signal %d for %d / %s\n", signo, rmp->mp_pid, rmp->mp_name);
        sys_diagctl_stacktrace(rmp->mp_endpoint);
    }

    exit_proc(rmp, 0, dump_core ? TRUE : FALSE);
}

/*===========================================================================*
 *				check_sig				     *
 *===========================================================================*/
int check_sig(proc_id, signo, ksig)
pid_t proc_id;			/* pid of proc to sig, or 0 or -1, or -pgrp */
int signo;			/* signal to send to process (0 to _NSIG-1) */
int ksig;			/* non-zero means signal comes from kernel  */
{
/* Check to see if it is possible to send a signal.  The signal may have to be
 * sent to a group of processes.  This routine is invoked by the KILL system
 * call, and also when the kernel catches a DEL or other signal.
 */

  register struct mproc *rmp;
  int count;			/* count # of signals sent */
  int error_code;

  if (signo < 0 || signo >= _NSIG) return(EINVAL);

  /* Return EINVAL for attempts to send SIGKILL to INIT alone. */
  if (proc_id == INIT_PID && signo == SIGKILL) return(EINVAL);

  /* Signal RS first when broadcasting SIGTERM. */
  if (proc_id == -1 && signo == SIGTERM)
      sys_kill(RS_PROC_NR, signo);

  /* Search the proc table for processes to signal. Start from the end of the
   * table to analyze core system processes at the end when broadcasting.
   * (See forkexit.c about pid magic.)
   */
  count = 0;
  error_code = ESRCH;
  for (rmp = &mproc[NR_PROCS-1]; rmp >= &mproc[0]; rmp--) {
	if (!(rmp->mp_flags & IN_USE)) continue;

	/* Check for selection. */
	if (proc_id > 0 && proc_id != rmp->mp_pid) continue;
	if (proc_id == 0 && mp->mp_procgrp != rmp->mp_procgrp) continue;
	if (proc_id == -1 && rmp->mp_pid <= INIT_PID) continue;
	if (proc_id < -1 && rmp->mp_procgrp != -proc_id) continue;

	/* Do not kill servers and drivers when broadcasting SIGKILL. */
	if (proc_id == -1 && signo == SIGKILL &&
		(rmp->mp_flags & PRIV_PROC)) continue;

	/* Skip VM entirely as it might lead to a deadlock with its signal
	 * manager if the manager page faults at the same time.
	 */
	if (rmp->mp_endpoint == VM_PROC_NR) continue;

	/* Disallow lethal signals sent by user processes to sys processes. */
	if (!ksig && SIGS_IS_LETHAL(signo) && (rmp->mp_flags & PRIV_PROC)) {
	    error_code = EPERM;
	    continue;
	}

	/* Check for permission. */
	if (mp->mp_effuid != SUPER_USER
	    && mp->mp_realuid != rmp->mp_realuid
	    && mp->mp_effuid != rmp->mp_realuid
	    && mp->mp_realuid != rmp->mp_effuid
	    && mp->mp_effuid != rmp->mp_effuid) {
		error_code = EPERM;
		continue;
	}

	count++;
	if (signo == 0 || (rmp->mp_flags & EXITING)) continue;

	/* 'sig_proc' will handle the disposition of the signal.  The
	 * signal may be caught, blocked, ignored, or cause process
	 * termination, possibly with core dump.
	 */
	sig_proc(rmp, signo, TRUE /*trace*/, ksig);

	if (proc_id > 0) break;	/* only one process being signaled */
  }

  /* If the calling process has killed itself, don't reply. */
  if ((mp->mp_flags & (IN_USE | EXITING)) != IN_USE) return(SUSPEND);
  return(count > 0 ? OK : error_code);
}

/*===========================================================================*
 *				check_pending				     *
 *===========================================================================*/
void check_pending(struct mproc *rmp)
{
    int i;

    if (rmp == NULL)
        return;

    for (i = 1; i < _NSIG; i++) {
        int is_pending = sigismember(&rmp->mp_sigpending, i);
        if (is_pending != 1)
            continue;

        {
            int is_blocked = sigismember(&rmp->mp_sigmask, i);
            if (is_blocked != 0)
                continue;
        }

        {
            int ksig = sigismember(&rmp->mp_ksigpending, i);
            sigdelset(&rmp->mp_sigpending, i);
            sigdelset(&rmp->mp_ksigpending, i);
            sig_proc(rmp, i, FALSE, ksig);
        }

        if (rmp->mp_flags & (VFS_CALL | EVENT_CALL)) {
            assert(rmp->mp_flags & PROC_STOPPED);
            break;
        }
    }
}

/*===========================================================================*
 *				restart_sigs				     *
 *===========================================================================*/
void restart_sigs(struct mproc *rmp)
{
    if (rmp == NULL) {
        return;
    }

    if (rmp->mp_flags & (VFS_CALL | EVENT_CALL | EXITING)) {
        return;
    }

    if (rmp->mp_flags & TRACE_EXIT) {
        exit_proc(rmp, rmp->mp_exitstatus, FALSE);
        return;
    }

    if (rmp->mp_flags & PROC_STOPPED) {
        assert(!(rmp->mp_flags & DELAY_CALL));
        check_pending(rmp);
        try_resume_proc(rmp);
    }
}

/*===========================================================================*
 *				unpause					     *
 *===========================================================================*/
static int unpause(struct mproc *rmp)
{
    message msg = (message){0};

    assert((rmp->mp_flags & (VFS_CALL | EVENT_CALL)) == 0);

    if ((rmp->mp_flags & UNPAUSED) != 0) {
        assert((rmp->mp_flags & (DELAY_CALL | PROC_STOPPED)) == PROC_STOPPED);
        return TRUE;
    }

    if ((rmp->mp_flags & DELAY_CALL) != 0) {
        return FALSE;
    }

    if ((rmp->mp_flags & (WAITING | SIGSUSPENDED)) != 0) {
        stop_proc(rmp, FALSE);
        return TRUE;
    }

    if (((rmp->mp_flags & PROC_STOPPED) == 0) && !stop_proc(rmp, TRUE)) {
        return FALSE;
    }

    msg.m_type = VFS_PM_UNPAUSE;
    msg.VFS_PM_ENDPT = rmp->mp_endpoint;

    tell_vfs(rmp, &msg);

    return FALSE;
}

/*===========================================================================*
 *				sig_send				     *
 *===========================================================================*/
static int
sig_send(struct mproc *rmp, int signo)
{
  struct sigmsg sigmsg;
  struct sigaction *sa;
  int i, result;
  int sigflags;
  int slot;

  assert(rmp != NULL);
  assert(signo > 0 && signo < _NSIG);
  assert(rmp->mp_flags & PROC_STOPPED);

  sa = &rmp->mp_sigact[signo];
  sigflags = sa->sa_flags;
  slot = (int)(rmp - mproc);

  sigmsg.sm_mask = (rmp->mp_flags & SIGSUSPENDED) ? rmp->mp_sigmask2 : rmp->mp_sigmask;
  sigmsg.sm_signo = signo;
  sigmsg.sm_sighandler = (vir_bytes)sa->sa_handler;
  sigmsg.sm_sigreturn = rmp->mp_sigreturn;

  for (i = 1; i < _NSIG; i++) {
    if (sigismember(&sa->sa_mask, i)) sigaddset(&rmp->mp_sigmask, i);
  }

  if (sigflags & SA_NODEFER) sigdelset(&rmp->mp_sigmask, signo);
  else sigaddset(&rmp->mp_sigmask, signo);

  if (sigflags & SA_RESETHAND) {
    sigdelset(&rmp->mp_catch, signo);
    sa->sa_handler = SIG_DFL;
  }

  sigdelset(&rmp->mp_sigpending, signo);
  sigdelset(&rmp->mp_ksigpending, signo);

  result = sys_sigsend(rmp->mp_endpoint, &sigmsg);
  if (result == EFAULT || result == ENOMEM) return FALSE;
  if (result != OK) panic("sys_sigsend failed: %d", result);

  if (rmp->mp_flags & (WAITING | SIGSUSPENDED)) {
    rmp->mp_flags &= ~(WAITING | SIGSUSPENDED);
    reply(slot, EINTR);
    assert(!(rmp->mp_flags & UNPAUSED));
    try_resume_proc(rmp);
    assert(!(rmp->mp_flags & PROC_STOPPED));
  } else {
    assert(rmp->mp_flags & UNPAUSED);
  }

  return TRUE;
}
